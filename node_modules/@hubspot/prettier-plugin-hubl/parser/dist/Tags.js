"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const parseSignature = (parser, nodes, lexer) => {
    var token = parser.peekToken();
    var parsedSignature = new nodes.NodeList(token.lineno, token.colno);
    var keywordArgs = new nodes.KeywordArgs();
    while (true) {
        token = parser.peekToken();
        if (token.type === lexer.TOKEN_BLOCK_END) {
            break;
        }
        if (token.type === lexer.TOKEN_COMMA) {
            parser.nextToken();
            continue;
        }
        var expression = parser.parseExpression();
        expression.type = token.type;
        expression.value = token.value;
        expression.lineno = token.lineno;
        expression.colno = token.colno;
        if (parser.skipValue(lexer.TOKEN_OPERATOR, "=")) {
            keywordArgs.type = "kw";
            const lhs = expression;
            lhs.type = "kw_key";
            let rhs;
            if (parser.tokens._extractString("{{")) {
                const parsedVariable = parser.tokens._extractUntil("}}");
                const symbolNode = new nodes.Symbol(token.lineno, token.colno, parsedVariable.trim());
                rhs = new nodes.Output(token.lineno, token.colno, [symbolNode]);
                parser.tokens.forwardN(2);
            }
            else {
                rhs = parser.parseExpression();
                rhs.type = "kw_val";
            }
            keywordArgs.addChild(new nodes.Pair(lhs.lineno, lhs.colno, expression, rhs));
        }
        else {
            parsedSignature.addChild(expression);
        }
    }
    if (keywordArgs.children.length) {
        parsedSignature.addChild(keywordArgs);
    }
    return parsedSignature;
};
function RemoteExtension() {
    this.tags = [
        "blog_comments",
        "blog_social_sharing",
        "blog_subscribe",
        "boolean",
        "choice",
        "comment",
        "color",
        "content_attribute",
        "cta",
        "custom_widget",
        "cycle",
        "dnd_area",
        "dnd_column",
        "dnd_module",
        "dnd_row",
        "dnd_section",
        "do",
        "email_each",
        "email_flex_area",
        "email_simple_subscription",
        "email_subscriptions",
        "email_subscriptions_confirmation",
        "endemail_each",
        "endflip",
        "end_content_attribute",
        "end_dnd_area",
        "end_dnd_column",
        "end_dnd_module",
        "end_dnd_row",
        "end_dnd_section",
        "end_email_each",
        "end_module_attribute",
        "end_widget_attribute",
        "end_widget_block",
        "flip",
        "include_dnd_partial",
        "follow_me",
        "form",
        "icon",
        "module",
        "module_attribute",
        "widget_attribute",
        "related_blog_posts",
        "widget_block",
        "with",
        "global_partial",
        "require_js",
        "require_css",
        "placeholder_block",
        "end_placeholder_block",
        "member_login",
        "module_block",
        "end_module_block",
        "scope_css",
        "end_scope_css",
        "member_register",
        "password_reset_request",
        "password_reset",
        "gallery",
        "global_module",
        "global_widget",
        "google_search",
        "header",
        "image",
        "image_slider",
        "image_src",
        "inline_rich_text",
        "inline_text",
        "language_switcher",
        "linked_image",
        "logo",
        "menu",
        "page_footer",
        "password_prompt",
        "post_filter",
        "post_listing",
        "print",
        "raw_html",
        "js_partial",
        "js_module",
        "require_head",
        "rich_text",
        "rss_listing",
        "section_header",
        "simple_menu",
        "social_sharing",
        "space",
        "style_settings",
        "targeted_module_attribute",
        "targeted_widget_attribute",
        "text",
        "textarea",
        "video_player",
        "widget_container",
        "widget_wrapper",
        "end_flip",
        "end_require_css",
        "end_require_head",
        "end_require_js",
        "end_style_settings",
        "end_targeted_module_attribute",
        "end_targeted_widget_attribute",
        "end_widget_container",
        "end_widget_wrapper",
    ];
    const blockTags = [
        { start: "comment", end: "end_comment" },
        { start: "content_attribute", end: "end_content_attribute" },
        { start: "dnd_area", end: "end_dnd_area" },
        { start: "dnd_column", end: "end_dnd_column" },
        { start: "dnd_module", end: "end_dnd_module" },
        { start: "dnd_row", end: "end_dnd_row" },
        { start: "dnd_section", end: "end_dnd_section" },
        { start: "email_each", end: "endemail_each" },
        { start: "flip", end: "end_flip" },
        { start: "module_attribute", end: "end_module_attribute" },
        { start: "module_block", end: "end_module_block" },
        { start: "require_css", end: "end_require_css" },
        { start: "require_head", end: "end_require_head" },
        { start: "require_js", end: "end_require_js" },
        { start: "scope_css", end: "end_scope_css" },
        { start: "style_settings", end: "end_style_settings" },
        {
            start: "targeted_module_attribute",
            end: "end_targeted_module_attribute",
        },
        {
            start: "targeted_widget_attribute",
            end: "end_targeted_widget_attribute",
        },
        { start: "widget_attribute", end: "end_widget_attribute" },
        { start: "widget_block", end: "end_widget_block" },
        { start: "widget_container", end: "end_widget_container" },
        { start: "widget_wrapper", end: "end_widget_wrapper" },
    ];
    this.parse = function (parser, nodes, lexer) {
        const tagWhiteSpace = {
            openTag: { start: parser.dropLeadingWhitespace, end: false },
            closingTag: { start: false, end: false },
        };
        const nextTag = parser.nextToken();
        nextTag.children = parseSignature(parser, nodes, lexer);
        const blockTag = blockTags.find((t) => t.start === nextTag.value);
        nextTag.type = blockTag ? "block_tag" : "tag";
        parser.advanceAfterBlockEnd(nextTag.value);
        tagWhiteSpace.openTag.end = parser.dropLeadingWhitespace;
        if (blockTag) {
            nextTag.body = parser.parseUntilBlocks(blockTag.end);
            tagWhiteSpace.closingTag.start = parser.dropLeadingWhitespace;
            parser.advanceAfterBlockEnd();
            tagWhiteSpace.closingTag.end = parser.dropLeadingWhitespace;
        }
        nextTag.whiteSpace = tagWhiteSpace;
        return nextTag;
    };
}
exports.default = RemoteExtension;
